# P2P Networking in TsengCoin

## Bootstrapping

When a node first joins the network, it must bootstrap by connecting to another node. Let's say for example that Node A wants to join the network through Node B:

1. Node A sends a GetAddr request to Node B requesting information about Node B and its neighbors. Node B can choose to reciprocate this connection and treat Node A as a peer. Currently, the default is for Node B to always treat Node A as a peer.
2. Node A begins "discovery" in which it tries to learn about more nodes on the network. Node B will have given Node A a list of its peers, so Node A asks those peers for their peers and adds them all to its list of known nodes. At the end of discovery, Node A randomly picks new peers from the list of known nodes it has now accumulated. Node A will pick at most 8 nodes, but if the network is small, it won't know 8 nodes to choose from, so it will just treat all of its known nodes as peers.
3. Finally, Node A floods the network with an Advertise request. The Advertise request serves to tell other nodes that Node A is in the network, so that those nodes can add Node A to their list of known nodes. When another node receives an Advertise request, there is a 50% chance it will also randomly promote new nodes to peers like Node A did at the end of the discovery step. This is to increase the likelihood of Node A being treated as a peer by other nodes.

## Architecture

The TsengCoin network is a directed graph. It may contain cycles and it may not be fully connected. Node A may be a peer of Node B, but the reverse may not be true - this is what we mean by a directed graph. In that case, Node B sends messages to Node A, but Node A does not initiate messages to Node B (besides responses). We chose not to cache TCP sockets because this proved to be very difficult in Rust for our use case. It made more sense to open a new socket for every communication - both because of difficulty in Rust but also because of our architecture; communication is generally not bidirectional and peers move around a lot.

_If we were to cache TCP connections, we would go for an approach in which there are two types of requests/responses: normal `Request`s and `PeerRequest`s for communication between connected peers. Normal `Request`s would serve as a public API and would be used by nodes wishing to start a peer connection. A separate thread would listen for these. When two nodes had agreed to be peers, they would exchange `PeerRequest`s. A newly connected peer would warrant the creation of a separate thread to handle the new connection. Peer threads would contain request handlers to respond to peer requests as they came through the tcp socket, and the main thread would be able to send peer requests to nodes and get responses back. We tried to build something like this, but it quickly became unclear who was allowed to read/write to the socket, and we didn't have a simple way to route incoming responses to the correct thread. We experimented with native channels/TcpStreams and async/await in tokio but ultimately we decided the best solution would be to not cache the TCP sockets._

A TsengCoin node runs a separate thread in which it listens for incoming connections. When another machine connects, the node expects it to send a serialized object of type `Request`. The `Request` type is an enum with several variants corresponding to different actions. Each `Request` has a corresponding `Response`; when a node sends a `Request` it expects a `Response` of the correct type. Nodes who abuse this and send the wrong type are not taken seriously and removed from the known node and peer lists (TODO: ban score).
