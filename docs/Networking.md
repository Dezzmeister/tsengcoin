# P2P Networking in TsengCoin

The TsengCoin network consists of nodes that listen for incoming TCP connections on a configurable port. When a node receives a connection, it attempts to deserialize the incoming data into an object of type Request. There are different types of “requests” in the core client, but a plain Request is just some binary data sent from another peer over TCP. We initially modeled our peer-to-peer messaging after HTTP requests. You make an HTTP request to a URL indicating the location of a resource. The type of request indicates what you want to do with the resource (GET, POST, PUT, etc.). Somewhere on the server, a router looks at the URL you’re trying to access and sends your HTTP request off to a handler function. We didn’t want to deal with the performance and latency overhead of HTTP, and we didn’t need the rigid HTTP structure of performing a specific action on a specific resource, so we chose to implement the router functionality with TCP messages and call them “requests.” So, Request is an enum indicating the things a peer can ask of another peer and the data it needs to provide to ask each thing. There’s a function in response.rs that routes each request to a handler function, and it is in the handler functions that a peer can decide how it wishes to respond to a request.

Some requests are meant to be propagated throughout the network, so the sender does not expect or wait for a response. In this case, the handler will disconnect immediately (so as not to hang up the sender) and process the request. Other requests are meant to be paired with a response. If a node sends one of these requests, it may keep the socket alive and wait for an object of type Response. In this case, the handler will try to respond as soon as it can, and do any remaining processing after it has responded to the request.

## Bootstrapping (Joining the Network)

When a node wishes to join the network, it must know about at least one node in the network. If there is no network, the top-level `start-seed` command can be used to skip the bootstrapping process and start an isolated node with no peers. In all other cases, the `connect` command should be used to join an existing network.

A node joining the network has one point of contact, another node, which it will use to learn about more nodes in the network. The joining node (Node A) sends a `GetAddr` request to the online node (Node B). In this request, Node A indicates the length of the longest chain in his blockchain, and the hash of the topmost block in this chain. Node A also indicates the address of Node B from his point of view, so that Node B can learn his own remote IP address if he didn’t know it already. Node B will respond to Node A with his best height, topmost hash, and Node A’s remote address. Node B will also include a list of his peers, so that Node A can get better acquainted with nodes in the network.

Node A will then begin discovery, in which it sends `GetAddr` requests to all of Node B’s peers and aggregates the resulting peers into a list of known nodes. After this process, Node A randomly selects new peers from the list of known nodes. The selection of new peers is entirely offline. Because we do not cache TCP connections, there is no handshake between prospective peers - for Node A to recognize another node as a peer it only needs to send the other node peer requests.
After discovering more nodes in the network, Node A sends an `Advertise` request to all of his peers containing his remote address and port. The peers forward the request on to their peers and so on until every node in the network has added Node A to its list of known nodes. The advertise step is done to increase the likelihood of other nodes choosing Node A as a peer. Peer relationships are one-way in TsengCoin, so just because Node A has five nodes on his peer list does not mean those five nodes have Node A on their peer lists.

If the network is large, Node A should have discovered plenty of nodes in the discovery step, and there is a good chance that at least one of those nodes has an updated copy of the blockchain. Node A will pick the node claiming to have the most updated copy of the blockchain and ask it for the blocks it doesn’t have - (from Node A’s top hash to the other node’s top hash). Node A expects the other node to send back a list of blocks. Node A will treat each block as if it has just been mined and propagated through the network - it will verify each block individually and add blocks one-by-one to its local copy of the blockchain. Because of the proof of work requirement, it is extremely difficult for one node to produce a chain of blocks better than any other chain, so Node A can be sure that it has the correct blocks.

## Network Redistribution

After bootstrapping, Node A has joined the network and can begin handling P2P requests. As mentioned before, some requests are meant to be propagated, and others are meant to be responded to. Of course, it would be inefficient for every node to treat every other node as a peer, because the former kind of request would quickly overload the network. TsengCoin uses a gossip protocol where each node has at most 8 peers. After every `Advertise` request from a previously unknown node, there is a 50% chance that a node chooses new peers at random from its list of known nodes (remember - this occurs completely offline and incurs no network overhead). To see why this is necessary, imagine a network with 9 nodes, where each node treats the other 8 as peers, and there is no method by which nodes choose new peers. If a tenth node wishes to join, it will treat 8 out of the 9 as peers, but because every other node already has 8 peers, nobody will treat the new node as a peer. In this case the network is “fully connected” and new nodes are completely shut out. To avoid this problem, nodes choose new peers at random every so often. Now imagine that the network has 9 nodes, and each node has a 50% chance of choosing 8 new peers whenever it receives an `Advertise` request from a previously unknown node. When a tenth node joins, each of the nine existing nodes will have a 50% chance of choosing 8 new nodes of 9 (not 10, because a node can’t choose itself). There are 9 ways to choose 8 nodes from 9, and 1 of these does not include the new node - so the probability of a node choosing the same peers given that it decided to choose new peers is 1/9. This means that upon the tenth node joining, each node has a 44.44% chance of choosing that node as a peer, and a 55.55% chance of not choosing that node as a peer. There are nine other nodes, so the probability that a new node does not get chosen by anybody as a peer is at most 0.5555^9, or 0.504%. This is a nonzero probability but it is sufficiently low for our purposes (testing small networks), and in practice a node in a network of 9 nodes likely does not know about every other node. Of course, we would need to improve our network algorithm for production use, because this means that there is at most a 1/200 chance that a node gets completely ignored by a network if it happens to join at the wrong time. Fortunately the node will likely be recognized as a peer when another node joins the network and triggers some nodes to choose new peers.

## Architecture

The TsengCoin network is a directed graph. It may contain cycles and it may not be fully connected. Node A may be a peer of Node B, but the reverse may not be true - this is what we mean by a directed graph. In that case, Node B sends messages to Node A, but Node A does not initiate messages to Node B (besides responses). We chose not to cache TCP sockets because this proved to be very difficult in Rust for our use case. It made more sense to open a new socket for every communication - both because of difficulty in Rust but also because of our architecture; communication is generally not bidirectional and peers move around a lot.

_If we were to cache TCP connections, we would go for an approach in which there are two types of requests/responses: normal `Request`s and `PeerRequest`s for communication between connected peers. Normal `Request`s would serve as a public API and would be used by nodes wishing to start a peer connection. A separate thread would listen for these. When two nodes had agreed to be peers, they would exchange `PeerRequest`s. A newly connected peer would warrant the creation of a separate thread to handle the new connection. Peer threads would contain request handlers to respond to peer requests as they came through the tcp socket, and the main thread would be able to send peer requests to nodes and get responses back. We tried to build something like this, but it quickly became unclear who was allowed to read/write to the socket, and we didn't have a simple way to route incoming responses to the correct thread. We experimented with native channels/TcpStreams and async/await in tokio but ultimately we decided the best solution would be to not cache the TCP sockets._

A TsengCoin node runs a separate thread in which it listens for incoming connections. When another machine connects, the node expects it to send a serialized object of type `Request`. The `Request` type is an enum with several variants corresponding to different actions. Some `Request`s have a corresponding `Response`; when a node sends a `Request` it may expect a `Response` of the correct type. A response is not expected for requests that are meant to be broadcasted. In the code, these types of one-way requests are called "messages." Nodes who abuse this and send the wrong type as a response are not taken seriously and removed from the known node and peer lists (TODO: ban score).

### Propagation

When receiving something that needs to be propagated, like a new transaction or block, a node will first check if it has already received the object. If it has, the request handler will stop running and the object will not be propagated. If it has not received the object in the past, the node will verify the object and ensure that it is indeed a valid transaction or object. It will only propagate the object if it is valid. In the future we plan to implement a "ban score" so that nodes who propagate invalid objects will receive a penalty. If a node accumulates a ban score high enough, it will be added to a blacklist.
